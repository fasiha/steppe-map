# -*- encoding: utf-8 -*-

from pyproj import Proj, transform
import numpy as np
import numpy.linalg as la
import scipy.linalg as scila
import scipy.optimize as opt

import pylab as plt
plt.ion()


def wgs84ToDeg(x, y):
    "Converts lat/lon from epsg:3857 (meters) to degrees"
    P3857 = Proj(init='epsg:3857')  # wgs84 in meters
    P4326 = Proj(init='epsg:4326')  # wgs84 in degrees
    return transform(P3857, P4326, x, y)


def loaddata(fname="gcp.txt", wgs84=False):
    """Load QGIS-style georeference control points (GCP) file.

    The first line will be skipped, and the rest of the lines are assumed to be
    comma-separated numbers.

    Four vectors will be returned:
    - lon, degrees,
    - lat, degrees,
    - x, pixel, and
    - y (pixel).

    If `wgs84` is truthy, lat/lon are treated as meters and converted to degrees.
    """
    arr = np.genfromtxt(fname, skip_header=1, delimiter=',')[:, :4]
    lon, lat, x, y = arr.T
    if wgs84:
        lon, lat = wgs84ToDeg(lon, lat)
    return (lon, lat, x, y)


def remove_polynomial2_2d(t, x, backwards=True):
    """
    For `t = [[t1], [t2]]` and `x = [[x1], [x2]]`, find `A` (2 by 5) and `b` (2 by 1) such that
    
    `t = A @ [[x1], [x2], [x1**2], [x2**2], [x*y]] + b`

    in the least-squares sense. Note that `x` and `t` must have two rows but any number of columns
    (2 by N).

    Returns a tuple:

    - A version of `x` with the quadratic relationship removed, `xnew`.
    - `x2t`, a function such that `x2t(x) = A @ [t, t**2, ...] + b`.
    - `t2x`, the adjoint of `x2t`, a function such that `t2x(t) = x` if `x` and `t` are quadratically-related.
      Calculated only if a keyword argument, `backwards` is True.
    - `A`, a 2 by 5 array
    - `b`, a 2 by 1 array

    If `t` is exactly a quadratic function of `x`, then `xnew=t` to machine precision.
    """
    maxx = np.max(x)
    y = np.vstack([x / maxx, x**2 / maxx**2, x[0] * x[1] / maxx**2, np.ones_like(x[0])])
    Ab = np.linalg.lstsq(y.T, t.T, rcond=None)[0].T
    A = Ab[:, :-1]
    b = Ab[:, -1:]
    x2t = lambda x: (A @ np.vstack([x/maxx, np.array(x/maxx)**2, np.array(x[0]/maxx) * np.array(x[1]/maxx)]) + b)
    if backwards:
        _, t2x, *_ = remove_polynomial2_2d(x, t, backwards=False)
    else:
        t2x = None
    return x2t(x), x2t, t2x, A, b


def remove_affine(p, q, q_factor=None, skip_factorization=False):
    """Removes an (unknown) affine transform between two matrixes.

    Given two arrays of the same size, `p` and `q`, finds a matrix `A` and
    column vector `t` such that

    `p = A * q + t`

    in the least-squares sense, and then computes `qnew = A * q + t`. (Notation:
    `matrix + vector` implies the vector is added to each column of the matrix.)

    NB: `p` and the returned `qnew` will be equal if and only if `p` is
    generated from `q` via an affine transform (no noise).

    Returns `(qnew, q_factor, Ahat, that)`. `q_factor` is a matrix factorization
    that can greatly speed up subsequent calls to remove_affine *with the same
    `q`*. If your `q` stays the same for multiple calls, cache `q_factor` and
    pass it in as a keyword argument; `q_factor` won't change from call to call.
    However, if your `q` change from call to call, ignore `q_factor` and pass in
    `skip_factorization=False` to avoid even calculating it. `Ahat` and `that`
    are the estimated values of `A` and `t`.

    NB2: the default `q_factor=None` will trigger computation of the
    factorization unless `skip_factorization=False`. Non-`None` `q_factor` will
    be trusted: no checks will be performed to make sure the given `q_factor` is
    indeed generated by the `q` you pass in. (Example: for `q.shape` of (2, 22),
    the speedup from using `q_factor` is 1.4x with skip_factorization=False, and
    1.3x the case with skip_factorization=True, on a 2009 Mac Book Pro.)

    Implements the algorithm described in H. Spath, "Fitting affine and
    orthogonal transformations between two sets of points" in *Mathematical
    Communications*, vol. 9 (2004), pp. 27--34. http://hrcak.srce.hr/file/1425

    """

    qaug = np.vstack([q, np.ones_like(q[0, :])])
    if q_factor is None:
        Q = np.dot(qaug, qaug.T)

        if skip_factorization:
            sol = la.lstsq(Q, np.dot(qaug, p.T))[0]
            q_factor = None

        else:
            q_factor = scila.cho_factor(Q)
            sol = scila.cho_solve(q_factor, np.dot(qaug, p.T))

    else:
        sol = scila.cho_solve(q_factor, np.dot(qaug, p.T))

    # sol.shape is (n+1, n), for n=p.shape[0]
    Ahat = sol[:-1, :].T  # top square matrix of sol, transposed
    that = sol[-1:, :].T  # bottom row vector of sol, transposed
    qnew = np.dot(Ahat, q) + that
    return (qnew, lambda x: Ahat @ x + that, lambda t: np.linalg.lstsq(Ahat, t - that), Ahat, that)


def search(lon, lat, x, y, proj, vec2dictfunc, init, order=2):
    """
    Given

    - `lon`: an array of longitudes in degrees
    - `lat`: an array of the same size as `lon`, giving latitudes in degrees
    - `x`: horizontal pixel locations, with 0 being leftmost and increasing to the right
    - `y`: vertical pixel locations, with 0 being upmost and DECREASING downwards (all should be
        negative!)
    - `proj`: a string of a projection Proj4 recognizes ('aea', 'wintri', etc.)
    - `vec2dictfunc`: a transformer function that, given a tuple of numbers, creates a dict with
        correct keys for the projection (`make_vector2dictfunc` can make these),
    - `init`: a vector of numbers, one for each projection parameter,
    - `order`: an integer, 1 meaning linear, 2 meaning quadratic.
    
    runs several nonlinear least squares methods to find the projection's parameters that bet fit
    the data. Returns a tuple of at least two elements:

    1. a vector of best-fit parameters,
    2. the final error,
    3. whatever else the minimizer might return.
    """
    xy = np.vstack([x, y])
    postfit = remove_polynomial2_2d if order == 2 else remove_affine

    def minimize(inputvec):
        p = Proj(proj=proj, **vec2dictfunc(inputvec))
        xout, yout = p(lon, lat)
        xout, yout = postfit(xy, np.vstack([xout, yout]))[0]
        return np.sum((xy - np.vstack([xout, yout]))**2)

    sols = []
    kws = dict(full_output=True, disp=False, xtol=1e-9, ftol=1e-9, maxiter=10000, maxfun=20000)
    sols.append(opt.fmin(minimize, init, **kws))
    sols.append(opt.fmin_powell(minimize, init, **kws))
    sols.append(opt.fmin_bfgs(minimize, init, full_output=True, disp=False))
    sols.append(opt.fmin_cg(minimize, init, gtol=1e-8, full_output=True, disp=False))
    fixmin = lambda res: [res['x'], res['fun']]
    sols.append(
        fixmin(
            opt.minimize(
                minimize,
                init,
                method="Nelder-Mead",
                tol=1e-9,
                options={
                    "xatol": 1e-9,
                    "fatol": 1e-9,
                    "maxfev": 20000,
                    "maxiter": 10000,
                    'disp': False
                })))

    best = np.argmin(map(lambda x: x[1], sols))
    xbest = sols[best][0]
    pbest = Proj(proj=proj, **vec2dictfunc(xbest))
    xynew, x2t, t2x, *_ = postfit(xy, np.vstack(pbest(lon, lat)))
    return sols[best], xynew, pbest, x2t, t2x


def make_vector2dictfunc(string, delimiter=','):
    """
    Given a string of projection parameters, like `"lat_0,lon_1"`, and a string delimiter,
    returns a function that converts a tuple of numbers to a dict. I.e.,
    ```
    (make_vector2dictfunction('lat_0,lon_1'))(1, 2) # {'lat_0' : 1, 'lon_1' : 2}
    ```
    """
    return lambda x: dict(zip(string.split(delimiter), np.atleast_1d(x)))


def loadshapefile():
    import os.path
    import shapefile
    import pyproj

    coastpath = os.path.join('ne', 'ne_10m_coastline', 'ne_10m_coastline')
    shppath = coastpath + '.shp'
    prjpath = coastpath + '.prj'

    try:
        from osgeo import osr

        # From http://gis.stackexchange.com/questions/17341/
        prjText = open(prjpath, 'r').read()
        srs = osr.SpatialReference()
        if (srs.ImportFromWkt(prjText)):
            print("error importing .prj information from ", prjpath)
            return (None, None)
        inProjection = pyproj.Proj(srs.ExportToProj4())
    except ImportError:
        inProjection = pyproj.Proj('+proj=longlat +ellps=WGS84 +no_defs')

    sf = shapefile.Reader(shppath)
    world = np.vstack(
        [shp.points for (rec, shp) in zip(sf.records(), sf.shapes()) if rec[1] <= 1.0]).T

    return (world, inProjection)


def shape2pixels(inproj, outproj, shape, x2t):
    shape = transform(inproj, outproj, *shape)
    xout, yout = x2t(shape)
    return np.array([xout, yout])


def myim(x, y, *args, **kwargs):
    def extents(f):
        delta = f[1] - f[0]
        return [f[0] - delta / 2, f[-1] + delta / 2]

    fig, ax = plt.subplots()
    im = ax.imshow(
        *args,
        **kwargs,
        aspect='auto',
        interpolation='none',
        extent=extents(x) + extents(y),
        origin='lower')
    return fig, ax, im


def image_show(x,
               y,
               xout,
               yout,
               imname="TheSteppe.jpg",
               description="",
               shape=None,
               inproj=None,
               outproj=None,
               x2t=None,
               **shapeargs):
    """Load and show an image with control points and estimates.

    Given control points in vectors x and y containing pixels, as well as
    estimates obtained (using some projection), plot both values so they can be
    visually compared.
    """
    try:
        im = plt.imread(imname)
    except IOError:
        print("Couldn't load {}, can't display image!".format(imname))
        return

    height, width = im.shape[:2]
    _, ax, *_ = myim(np.arange(width), -np.arange(height), im)
    plt.gca().invert_yaxis()

    ll2pix2 = lambda lon, lat, x2t, p: x2t(p(lon, lat))
    for l in range(-10, 180, 10):
        plt.plot(*ll2pix2(np.ones(100) * l, np.linspace(0, 85, 100), x2t, outproj), 'r', lw=.5)
    for l in range(10, 85, 10):
        plt.plot(*ll2pix2(np.linspace(-10, 180, 100), np.ones(100) * l, x2t, outproj), 'r', lw=.5)

    if shape is not None:
        (shapex, shapey) = shape2pixels(inproj, outproj, shape, x2t)
        plt.scatter(shapex, shapey, s=1.0, marker='.', label='Coastline', **shapeargs)

    plt.scatter(xout, yout, marker='v', label='Fitted GCPs')
    plt.scatter(x, y, marker='^', label='Original GCPs')

    plt.xlim([0, width])
    plt.ylim([-height, 0])
    plt.title(description)
    plt.legend(loc='lower left')
    return ax


def manualinterpolate(im, t2x, p, outLon=None, outLat=None, degPerPix=0.05, fname=None):
    pixToLonlat = lambda x, y: p(*t2x([x, y]), inverse=True)

    height, width, _ = im.shape
    xs, ys = np.meshgrid(np.arange(width), -np.arange(height))
    origLon, origLat = pixToLonlat(xs.ravel(), ys.ravel())
    vecToBounds = lambda x: np.array([np.min(x), np.max(x)])
    boundLon = vecToBounds(origLon)
    boundLat = vecToBounds(origLat)

    if outLon is None or outLat is None:
        outLon, outLat = np.meshgrid(
            np.arange(boundLon[0] - 0.5, boundLon[1] + 0.5, degPerPix),
            np.arange(boundLat[0] - 0.5, boundLat[1] + 0.5, degPerPix))

    from scipy.interpolate import griddata
    res = np.dstack([
        griddata(
            np.vstack([origLon, origLat]).T,
            im[:, :, i].ravel(),
            np.vstack([outLon.ravel(), outLat.ravel()]).T,
            method='nearest').reshape(outLon.shape) for i in range(3)
    ])
    if fname:
        plt.imsave(fname=fname, arr=res[::-1, :, :])
        earthRadius = 6378137
        mPerDeg = np.pi / 180 * earthRadius
        print("""{} saved.
top_left_lon={},
top_left_lat={},
bottom_right_lon={},
bottom_right_lat={}""".format(fname, outLon[0, 0], outLat[-1, -1], outLon[-1, -1], outLat[0, 0]))
        print("To convert to a georegistered GeoTIFF, run:")
        print(("gdal_translate -of GTiff -a_ullr {top_left_lon} {top_left_lat} {bottom_right_lon}" +
               " {bottom_right_lat} -a_srs EPSG:32662 {fname} output.tif").format(
                   top_left_lon=outLon[0, 0] * mPerDeg,
                   top_left_lat=outLat[-1, -1] * mPerDeg,
                   bottom_right_lon=outLon[-1, -1] * mPerDeg,
                   bottom_right_lat=outLat[0, 0] * mPerDeg,
                   fname=fname))

    return res, outLon, outLat


if __name__ == "__main__":
    (shape, shapeproj) = loadshapefile()
    (lon, lat, x, y) = loaddata('gcp29.points', True)

    def searchsolution2xy(proj,
                          parametersString,
                          init,
                          lon=lon,
                          lat=lat,
                          x=x,
                          y=y,
                          order=2,
                          plot=True,
                          description="",
                          shape=shape,
                          inproj=shapeproj):
        vec2dictfunc = make_vector2dictfunc(parametersString)
        sol, (xout, yout), p, x2t, t2x = search(lon, lat, x, y, proj, vec2dictfunc, init, order)
        if plot:
            descriptor = "%s%s projection (%s, %s, fit error %.3f)" % (description, proj,
                                                                       parametersString, 'poly1'
                                                                       if order == 1 else 'poly2',
                                                                       sol[1])
            image_show(
                x,
                y,
                xout,
                yout,
                description=descriptor,
                shape=shape,
                inproj=inproj,
                outproj=p,
                x2t=x2t)
        return p, x2t, t2x

    pixToLonlat2 = lambda x, y, t2x, p: p(*t2x([x, y]), inverse=True)
    ll2pix2 = lambda lon, lat, x2t, p: x2t(p(lon, lat))
    earthRadius = 6378137
    mPerDeg = np.pi / 180 * earthRadius

    # Albers equal-area, 4-parameter, poly2 (quadratic)
    p, x2t, t2x = searchsolution2xy('aea', "lon_0,lat_0,lat_1,lat_2", [80.0, 50, 40, 60])
    plt.savefig('aea.png', dpi=200)

    # TWO-parameter Winkel Tripel, poly1 (affine)
    p, x2t, t2x = searchsolution2xy('wintri', "lon_0,lat_1", [47., 0.], order=1)
    print("Two-parameter Winkel Tripel, affine, SRS: ", p.srs)
    plt.savefig('wintri-lon_0-lat_1.png', dpi=200)

    # Same as above, but poly2
    p, x2t, t2x = searchsolution2xy('wintri', "lon_0,lat_1", [47., 0.], order=2)
    plt.savefig('wintri-lon_0-lat_1-quadratic.png', dpi=200)

    # Load image
    import pylab as plt
    im = plt.imread('TheSteppe.jpg')
    height, width = im.shape[:2]
    if not (height == 1058 and width == 1600):
        print(
            "Geo-control poins (GCPs) expect a 1600x1058 image but TheSteppe.jpg is not that size")

    # Manual interpolation to equirectangular projection.
    print('Equirectangular interpolation started, might take two minutes…', end='')
    res, outLon, outLat = manualinterpolate(im, t2x, p, degPerPix=0.05, fname='outfine.png')
    print(' done!')
